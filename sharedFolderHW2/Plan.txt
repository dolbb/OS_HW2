1. New system calls:
	
	Definition of done:
		-	Calling the specified system call will print "System call #___"
	
	Steps:
		1.1	entry.S:			Add 3 values
		1.2	hw2_syscalls.h:		Wrappers implementation
		1.3	hw2_syscalls.c:		Empty system calls implementation (printk)

---------------------------------------------------------------------------
		
2. Classify process as SHORT:
	
	Definition of done:
		-	System calls return valid values before and after becoming short
		-	SCHED_SHORT process still schedules as SCHED_OTHER
	
	Steps:
		2.1	Add to task_struct (sched.h):
			-	"int requested_time"
			-	"int iAmOverdue"
			-	"int iWasShort"
			
		2.2 Add SCHED_SHORT constants (sched.h):
			-	"#define SCHED_SHORT 5"
			-	"#define MAX_REQUESTED_TIME 3000"
			-	"#define INVALID_REQUESTED_TIME 4000"
			
		2.3 Add to sched_param (sched.h):
			-	"int requested_time"

		2.2 sched.c:			
			Update setscheduler (called by sched_setscheduler)
			-	Support SCHED_SHORT
			-	Save parameter in requestedTime
			-	Update time_slice
			
		2.3 Update hw2_syscalls.c:		
			Access and return the related fields from task struct.

---------------------------------------------------------------------------

3. Support new data structures for SCHED_SHORT:
	
	Definition of done:
		-	Same as step 2
		-	Overdue short won't schedule
	
	Steps:
		3.1	Add data structures:	
			-	sched.c		struct prio_array:	Add "unsigned long bitmap_short[BITMAP_SIZE]"
			-	sched.c		struct runqueue:	Add "list_t overdure_short";
			
		3.2 Initialize data structures:
			-	sched.c		sched_init():		Initialize bitmap_short
												Initialize overdure_short
		
		3.3 Maintain (Everything is in sched.c):
		
			*** Notice:	changing a data structure (runqueue, prio_array, task_struct...) requires locks !	***
		
			-	setscheduler():		** Need to update sleep_avg ?? If yes - use and activate_task deactivate_task
									dequeue_task()				
									p->prio = effective_prio()
									enqueue_task()
			
		
			-	dequeue_task():		If SCHED_SHORT update bitmap_short
			
			-	enqueue_task():		If SCHED_SHORT update bitmap_short
			
			-	effective_prio():	If SCHED_SHORT 	p->prio = static_prio
			
			-	TASK_TIMESLICE():	If (SCHED_SHORT && iAmOverdue) return "requested_time * HZ / 1000"
									If (SCHED_SHORT && !iAmOverdue) return "2 * requested_time * HZ / 1000"
		
			-	scheduler_tick():	move from "overdure_short" to "active"
									p->policy = SCHED_OTHER
									
									"if (p->array != rq->active)" - skip this for Overdue 
									Support short->overdue, overdue->other (see ControlPaths.txt)	
		
									SHORT becomes overdue:
									remove from "active"
									time_slice = 2 * requested_time * HZ / 1000
									insert to tail of "overdure_short"
		
			-	sys_sched_yield():	If SCHED_SHORT:	call clear_bit()+set_bit() with "bitmap_short"
									If overdue:
				
---------------------------------------------------------------------------

4. Support scheduling SCHED_SHORT:

	Definition of done:	Correct order of scheduling
		 
	Steps:
		- sched.c	sched_find_first_bit()		set order of scheduling (rt, SCHED_SHORT, SCHED_OTHER)
		
---------------------------------------------------------------------------
		
5.	Forking a SHORT process:

	Definition of done:	

	Steps:

---------------------------------------------------------------------------
